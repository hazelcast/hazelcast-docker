name: Push EE RHEL image

on:
  workflow_dispatch:
    inputs:
      HZ_VERSION:
        description: 'Version of Hazelcast to build the image for, e.g. 5.1.1, 5.0.1'
        required: true
      JDKS:
        description: 'Supported JDKs - e.g. `[17, 21]`'
        required: true
      IS_LATEST_LTS:
        description: 'Is Latest LTS? e.g. `false`'
        required: true
      DEFAULT_JDK:
        description: 'The Java major version (e.g. `21`, `8`) used by default in the image'
        required: true
      ENVIRONMENT:
        description: 'Environment to use'
        required: true
        type: environment
  workflow_call:
    inputs:
      HZ_VERSION:
        description: 'Version of Hazelcast to build the image for, e.g. 5.1.1, 5.0.1'
        required: true
        type: string
      JDKS:
        description: 'Supported JDKs - e.g. `[17, 21]`'
        required: true
        type: string
      IS_LATEST_LTS:
        description: 'Is Latest LTS? e.g. `false`'
        required: true
        type: string
      DEFAULT_JDK:
        description: 'The Java major version (e.g. `21`, `8`) used by default in the image'
        required: true
        type: string
      ENVIRONMENT:
        description: 'Environment to use'
        required: true
        type: string
jobs:
  build:
    env:
      SCAN_REGISTRY: "quay.io"
    environment: ${{ inputs.ENVIRONMENT }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        jdk: ${{ fromJSON(inputs.JDKS) }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - uses: madhead/semver-utils@latest
        id: version
        with:
          version: ${{ inputs.HZ_VERSION }}

      - name: Set scan registry secrets
        id: scan_registry_secrets
        run: |
          # Some repositories have a separate projects for each (major) version
          # First see if a version-specific secret exists, falling back to default

          PROJECT_ID=${{ secrets[format('RHEL_PROJECT_ID_V{0}', steps.version.outputs.major)] }}
          if [[ -z "${PROJECT_ID}" ]]; then
            PROJECT_ID=${{ secrets.RHEL_PROJECT_ID }}
          fi
          echo "PROJECT_ID=${PROJECT_ID}" >> ${GITHUB_OUTPUT}

          echo "USERNAME=redhat-isv-containers+${PROJECT_ID}-robot" >> ${GITHUB_OUTPUT}

          PASSWORD=${{ secrets[format('SCAN_REGISTRY_PASSWORD_V{0}', steps.version.outputs.major)] }}
          if [[ -z "${PASSWORD}" ]]; then
            PASSWORD=${{ secrets.SCAN_REGISTRY_PASSWORD }}
          fi
          echo "PASSWORD=${PASSWORD}" >> ${GITHUB_OUTPUT}

          echo "SCAN_REPOSITORY=${SCAN_REGISTRY}/redhat-isv-containers/${PROJECT_ID}" >> ${GITHUB_OUTPUT}

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Log in to Red Hat Scan Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.SCAN_REGISTRY }}
          username: ${{ steps.scan_registry_secrets.outputs.USERNAME }}
          password: ${{ steps.scan_registry_secrets.outputs.PASSWORD }}

      - name: Get tags to push
        id: get-tags-to-push
        run: |
          . .github/scripts/get-tags-to-push.sh

          if [[ "${{ inputs.HZ_VERSION }}" =~ SNAPSHOT ]]; then
            TAGS_TO_PUSH=$(augment_with_classifier_tags "${{ inputs.HZ_VERSION }}" "" "${{ matrix.jdk }}" "${{ inputs.DEFAULT_JDK }}")
          else
            TAGS_TO_PUSH=$(get_tags_to_push "${{ inputs.HZ_VERSION }}" "" "${{ matrix.jdk }}" "${{ inputs.DEFAULT_JDK }}" "${{ inputs.IS_LATEST_LTS }}")
          fi

          echo "all_destination_tags=${TAGS_TO_PUSH}" >> ${GITHUB_OUTPUT}

          # We need to add a new, unique tag for each image to workaround RedHat bug - https://github.com/hazelcast/hazelcast-docker/pull/1088
          #
          # When an new image re-using an _existing_ tag (implicitly unpublished) is pushed to the registry, the _existing_ image is immediately replaced.
          # This means until the new image is published, the tag existing tag appears not to work for users
          #
          # We can leverage this new, unique tag to validate, push and publish the _new_ image without affecting the _existing_ image
          # First we push the _new, unique_ tag, then after validation we can add the _existing_ tags

          # Pick an (arbitrary) tag to pull from
          SOURCE_TAG=${TAGS_TO_PUSH%% *}
          echo "source_tag=${SOURCE_TAG}" >> ${GITHUB_OUTPUT}

          # Add date suffix to create unique output tag (e.g. 5.4.1-jdk17-20250909130347)
          echo "unique_destination_tag=${SOURCE_TAG}-$(date +"%Y%m%d%H%M%S")" >> ${GITHUB_OUTPUT}

      - name: Copy new unique tag to RedHat Container Registry
        run: |
          # Deliberately only copy a single architecture - https://github.com/hazelcast/hazelcast-docker/pull/1042#issuecomment-3141395993
          skopeo copy \
            --override-os linux \
            --override-arch amd64 \
            docker://${{ vars.DOCKERHUB_NAMESPACE }}/${{ vars.DOCKERHUB_EE_IMAGE_NAME }}:${{ steps.get-tags-to-push.outputs.source_tag }} \
            docker://${{ steps.scan_registry_secrets.outputs.SCAN_REPOSITORY }}:${{ steps.get-tags-to-push.outputs.unique_destination_tag }}

      - name: Install `preflight` OpenShift tool from GitHub
        uses: redhat-actions/openshift-tools-installer@v1
        with:
          preflight: "latest"
          source: github

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_DEV_INFRA_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_DEV_INFRA_SECRET_ACCESS_KEY }}
          aws-region: 'us-east-1'

      - name: Get Secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            REDHAT_ROBOT,REDHAT/REDHAT_ISV_CONTAINERS_ROBOT
          parse-json-secrets: true
   
      - name: Run preflight scan
        id: preflight
        run: |
          source .github/scripts/logging.functions.sh

          PREFLIGHT_OUTPUT=$(preflight check container "${{ steps.scan_registry_secrets.outputs.SCAN_REPOSITORY }}:${{ steps.get-tags-to-push.outputs.unique_destination_tag }}" \
            --submit --pyxis-api-token=${REDHAT_ROBOT_RHEL_API_KEY} \
            --certification-component-id=${{ steps.scan_registry_secrets.outputs.PROJECT_ID }} \
            --docker-config ~/.docker/config.json \
            2>&1)

          echodebug "${PREFLIGHT_OUTPUT}"

          # Multi-arch images will have multiple image IDs
          IMAGE_IDS=$(grep --perl-regexp --only-matching "image id is: \K[a-f0-9]+" <<< "${PREFLIGHT_OUTPUT}" || true)

          if [[ -n "${IMAGE_IDS}" ]]; then
            IMAGE_IDS_JSON=$(jq --raw-input --slurp --compact-output 'split("\n")[:-1]' <<< "${IMAGE_IDS}")
            echo "IMAGE_IDS=${IMAGE_IDS_JSON}" >> ${GITHUB_OUTPUT}
          else
            echoerr "Unable to extract image ID from preflight output:"
            echoerr "${PREFLIGHT_OUTPUT}"
            exit 1
          fi

      - name: Await publishing
        timeout-minutes: 240
        run: |
          . .github/scripts/rhel.functions.sh

          # Although we use autopublish, this simply triggers an asynchronous process on the server side
          # To _try_ to attain republish atomicity, we want to await the successful publishing of the new, unique tag _before_ we push (and implicitly replace) the existing tags
          # Otherwise we'd replace a published image with an unpublished one

          jq --raw-output '.[]' <<< '${{ steps.preflight.outputs.IMAGE_IDS }}' | while read IMAGE_ID; do
            await_image_publish \
              "${{ steps.scan_registry_secrets.outputs.PROJECT_ID }}" \
              "${IMAGE_ID}" \
              "${REDHAT_ROBOT_RHEL_API_KEY}"
          done

      - name: Copy remaining tags to RedHat Container Registry
        run: |
          for tag in ${TAGS_TO_PUSH[@]}
          do
            skopeo copy \
              docker://${{ steps.scan_registry_secrets.outputs.SCAN_REPOSITORY }}:${{ steps.get-tags-to-push.outputs.unique_destination_tag }} \
              docker://${{ steps.scan_registry_secrets.outputs.SCAN_REPOSITORY }}:${tag}
          done
        env:
          TAGS_TO_PUSH: ${{ steps.get-tags-to-push.outputs.all_destination_tags }}

      - name: Check RedHat service status
        if: failure()
        uses: hazelcast/docker-actions/check-redhat-service-status@master
