name: Push EE RHEL image

on:
  workflow_dispatch:
    inputs:
      HZ_VERSION: &INPUT_HZ_VERSION
        description: 'Version of Hazelcast to build the image for, e.g. 5.1.1, 5.0.1'
        required: true
        type: string
      JDKS: &INPUT_JDKS
        description: 'Supported JDKs - e.g. `[17, 21]`'
        required: true
        type: string
      IS_LATEST_LTS: &INPUT_IS_LATEST_LTS
        description: 'Is Latest LTS? e.g. `false`'
        required: true
        type: string
      DEFAULT_JDK: &INPUT_DEFAULT_JDK
        description: 'The Java major version (e.g. `21`, `8`) used by default in the image'
        required: true
        type: string
      ENVIRONMENT:
        description: 'Environment to use'
        required: true
        type: environment
  workflow_call:
    inputs:
      HZ_VERSION: *INPUT_HZ_VERSION
      JDKS: *INPUT_JDKS
      IS_LATEST_LTS: *INPUT_IS_LATEST_LTS
      DEFAULT_JDK: *INPUT_DEFAULT_JDK
      ENVIRONMENT:
        description: 'Environment to use'
        required: true
        type: string
jobs:
  push-rhel:
    env:
      SCAN_REGISTRY: "quay.io"
    environment: ${{ inputs.ENVIRONMENT }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    strategy:
      fail-fast: false
      matrix:
        jdk: ${{ fromJSON(inputs.JDKS) }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - uses: madhead/semver-utils@latest
        id: version
        with:
          version: ${{ inputs.HZ_VERSION }}

      - name: Set scan registry secrets
        id: scan_registry_secrets
        env:
          # Some repositories have a separate projects for each (major) version
          # First see if a version-specific secret exists, falling back to default
          RHEL_PROJECT_ID: ${{ secrets[format('RHEL_PROJECT_ID_V{0}', steps.version.outputs.major)] || secrets.RHEL_PROJECT_ID }}
          SCAN_REPOSITORY: ${{ secrets[format('SCAN_REPOSITORY_V{0}', steps.version.outputs.major)] || secrets.SCAN_REPOSITORY }}
        run: |
          echo "PROJECT_ID=${RHEL_PROJECT_ID}" >> ${GITHUB_OUTPUT}
          echo "SCAN_REPOSITORY=${SCAN_REPOSITORY}${SCAN_REGISTRY}/redhat-isv-containers/${RHEL_PROJECT_ID}" >> ${GITHUB_OUTPUT}

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Log in to Red Hat Scan Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.SCAN_REGISTRY }}
          # Some repositories have a separate projects for each (major) version
          # First see if a version-specific secret exists, falling back to default
          username: redhat-isv-containers+${{ steps.scan_registry_secrets.outputs.PROJECT_ID }}-robot
          password: ${{ secrets[format('SCAN_REGISTRY_PASSWORD_V{0}', steps.version.outputs.major)] || secrets.SCAN_REGISTRY_PASSWORD }}

      - id: get-tags-to-push
        uses: ./.github/actions/get-tags-to-push
        with:
          hz-version: ${{ inputs.HZ_VERSION }}
          jdk: ${{ matrix.jdk }}
          default-jdk: ${{ inputs.DEFAULT_JDK }}
          classifier: ""
          is-latest-lts: ${{ inputs.IS_LATEST_LTS }}

      - id: unique-destination-tag
        run: |
          # We need to add a new, unique tag for each image to workaround RedHat bug - https://github.com/hazelcast/hazelcast-docker/pull/1088
          #
          # When an new image re-using an _existing_ tag (implicitly unpublished) is pushed to the registry, the _existing_ image is immediately replaced.
          # This means until the new image is published, the tag existing tag appears not to work for users
          #
          # We can leverage this new, unique tag to validate, push and publish the _new_ image without affecting the _existing_ image
          # First we push the _new, unique_ tag, then after validation we can add the _existing_ tags

          # Add date suffix to create unique output tag (e.g. 5.4.1-jdk17-20250909130347)
          echo "tag=${{ steps.get-tags-to-push.outputs.primary-tag }}-$(date +"%Y%m%d%H%M%S")" >> ${GITHUB_OUTPUT}

      - name: Copy new unique tag to RedHat Container Registry
        run: |
          # Deliberately only copy a single architecture - https://github.com/hazelcast/hazelcast-docker/pull/1042#issuecomment-3141395993
          skopeo copy \
            --override-os linux \
            --override-arch amd64 \
            docker://${{ vars.DOCKERHUB_NAMESPACE }}/${{ vars.DOCKERHUB_EE_IMAGE_NAME }}:${{ steps.get-tags-to-push.outputs.primary-tag }} \
            docker://${{ steps.scan_registry_secrets.outputs.SCAN_REPOSITORY }}:${{ steps.unique-destination-tag.outputs.tag }}

      - name: Install `preflight` OpenShift tool from GitHub
        uses: redhat-actions/openshift-tools-installer@v1
        with:
          preflight: "latest"
          source: github

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_DEV_INFRA_OIDC_GITHUB_ACTIONS_ROLE_ARN }}
          aws-region: 'us-east-1'

      - name: Get Secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            REDHAT_ROBOT,REDHAT/REDHAT_ISV_CONTAINERS_ROBOT
          parse-json-secrets: true
   
      - name: Run preflight scan
        id: preflight
        run: |
          source .github/scripts/logging.functions.sh

          PREFLIGHT_OUTPUT=$(preflight check container "${{ steps.scan_registry_secrets.outputs.SCAN_REPOSITORY }}:${{ steps.unique-destination-tag.outputs.tag }}" \
            --submit --pyxis-api-token=${REDHAT_ROBOT_RHEL_API_KEY} \
            --certification-component-id=${{ steps.scan_registry_secrets.outputs.PROJECT_ID }} \
            --docker-config ~/.docker/config.json \
            2>&1)

          echodebug "${PREFLIGHT_OUTPUT}"

          # Multi-arch images will have multiple image IDs
          IMAGE_IDS=$(grep --perl-regexp --only-matching "image id is: \K[a-f0-9]+" <<< "${PREFLIGHT_OUTPUT}" || true)

          if [[ -n "${IMAGE_IDS}" ]]; then
            IMAGE_IDS_JSON=$(jq --raw-input --slurp --compact-output 'split("\n")[:-1]' <<< "${IMAGE_IDS}")
            echo "IMAGE_IDS=${IMAGE_IDS_JSON}" >> ${GITHUB_OUTPUT}
          else
            echoerr "Unable to extract image ID from preflight output:"
            echoerr "${PREFLIGHT_OUTPUT}"
            exit 1
          fi

      - name: Await publishing
        timeout-minutes: 240
        run: |
          set -o errexit ${RUNNER_DEBUG:+-x}

          . .github/scripts/rhel.functions.sh

          # Although we use autopublish, this simply triggers an asynchronous process on the server side
          # To _try_ to attain republish atomicity, we want to await the successful publishing of the new, unique tag _before_ we push (and implicitly replace) the existing tags
          # Otherwise we'd replace a published image with an unpublished one

          jq --raw-output '.[]' <<< '${{ steps.preflight.outputs.IMAGE_IDS }}' | while read IMAGE_ID; do
            await_image_publish \
              "${IMAGE_ID}" \
              "${REDHAT_ROBOT_RHEL_API_KEY}"
          done

      - name: Copy remaining tags to RedHat Container Registry
        run: |
          for tag in ${TAGS_TO_PUSH[@]}
          do
            skopeo copy \
              docker://${{ steps.scan_registry_secrets.outputs.SCAN_REPOSITORY }}:${{ steps.unique-destination-tag.outputs.tag }} \
              docker://${{ steps.scan_registry_secrets.outputs.SCAN_REPOSITORY }}:${tag}
          done
        env:
          TAGS_TO_PUSH: ${{ steps.get-tags-to-push.outputs.all-destination-tags }}

      - name: Check RedHat service status
        if: failure()
        uses: hazelcast/docker-actions/check-redhat-service-status@master
